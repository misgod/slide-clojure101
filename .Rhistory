z = sign(wf)
pla(x, y, z)
set.seed(100)
x = rnorm(20)
y = rnorm(20)
wf = x + 3*y +0.1
z = sign(wf)
pla(x, y, z)
z
wf
wf = x + 3*y +0.1
source('~/.active-rstudio-document')
}
set.seed(100)
x = rnorm(20)
y = rnorm(20)
source('~/.active-rstudio-document')
traindata <- read.table("~/Dropbox/coursera/\xB8\xF2\x7A\x73/ass1/ntumlone_hw1_hw1_15_train.dat", dec=",", quote="")
View(traindata)
train <- read.table("/tmp/ass1/ntumlone_hw1_hw1_15_train.dat", dec=",", quote="")
View(train)
train(2)
train
train[1:]
train[[1]]
train[[2]]
train[[3]]
train[1,
]
train[,1]
train[,[1,3]
train[,[1,3]]
train[,1:3]
view(train[,1:4])
View(train[,1:4])
View(train[,5])
c(0,0,0)
view(cbind(1,train[,1:4]))
View(cbind(1,train[,1:4]))
print 1
print(1)
source('~/Dropbox/coursera/學習基石/PLA.R')
source('~/Dropbox/coursera/學習基石/PLA.R')
X = cbind(1, x)
X
w
source('~/Dropbox/coursera/學習基石/PLA.R')
w = c(0,0,0,0,0)
w
X %*% w
X
w
X * w
crossprod(X,w)
X %*% w
X
w
r(0,0,0,0,0)
X %*% t(w)
t(w)
t(t(w))
X %*% t(t(w))
w = list()
w[[1]] = c(0,0,0,0,0)
w
w %*% w
X %*% X
X %*% t(X)
a = X %*% t(X)
X
help
a = X %*% t(X)
a = X %*% t(X)
str(X)
str(w)
a = as.numeric(X) %*% t(X)
a = as.numeric(t(X) %*% t(X)
)
a = as.numeric(t(X)) %*% t(X)
a = as.numeric(t(X)) %*% w
View(X)
View(X)
View(X)
View(X)
View(X)
View(X)
View(train)
train <- read.table("/tmp/ass1/ntumlone_hw1_hw1_15_train.dat", quote="\"")
View(train)
a = as.numeric(t(X)) %*% t(X)
X %*% 3
X * 3
X * 3.0
View(X)
View(X)
View(X)
View(X)
View(X)
9,9,9,9,9,9,9,9,,,,,,,,,,,,,,,,,", sep=",", fill=TRUE, colClasses=c(rep("numeric", 8), rep("NULL", 30)) )
read.table(text="1,2,3,4,5,6,7,8,,,,,,,,,,,,,,,,,,
9,9,9,9,9,9,9,9,,,,,,,,,,,,,,,,,", sep=",", fill=TRUE, colClasses=c(rep("numeric", 8), rep("NULL", 30)) )
train <- read.delim("/tmp/ass1/ntumlone_hw1_hw1_15_train.dat", header=F, quote="")
View(train)
train <- read.table("/tmp/ass1/ntumlone_hw1_hw1_15_train.dat", header=F, as.is=T)
ntumlone_hw1_hw1_15_train <- read.table("/tmp/ass1/ntumlone_hw1_hw1_15_train.dat", quote="")
View(ntumlone_hw1_hw1_15_train)
train <- read.table("/tmp/ass1/ntumlone_hw1_hw1_15_train.dat", quote="",as.is=T )
View(train)
source('~/.active-rstudio-document')
View(X)
View(X)
train
View(X)
View(train)
View(ntumlone_hw1_hw1_15_train)
View(train)
ntumlone_hw1_hw1_15_train <- read.table("/tmp/ass1/ntumlone_hw1_hw1_15_train.dat", dec=",", quote="")
View(ntumlone_hw1_hw1_15_train)
View(ntumlone_hw1_hw1_15_train)
View(ntumlone_hw1_hw1_15_train)
train <- ntumlone_hw1_hw1_15_train
View(train)
View(train)
View(train)
source('~/.active-rstudio-document')
X
w = list()
w[[1]] = w0
w[[1]] = c(0,0,0,0,0)
X = cbind(1, x)
View(X)
View(ntumlone_hw1_hw1_15_train)
View(X)
View(ntumlone_hw1_hw1_15_train)
View(train)
View(X)
X %*% w[[1]]
X %*% w[[1]]
X
X[1]
X[2,2]
X[2,2] + x[3,3]
mode(X)
mode(X[2,2])
X %*% w[[1]]
X %*% w[[0]]
X %*% w[[]]
X %*% w[
t]
X %*% w[t]
X %*% w[[t]
]
X %*% w[1]
as.matrix(X) %*% w[1]
as.matrix(X) %*% as.matrix(w[1])
t(as.matrix(X)) %*% as.matrix(w[1])
str(X)
data.matrix(X)
t(data.matrix(X)) %*% as.matrix(w[1])
t(data.matrix(X)) %*% data.matrix(w[1])
as.matrix(X)
data.matrix(X)
X
X %*% X
X %*% t(X)
t(X)
X %*% t(X)
a = X %*% t(X)
X %*% t(X)
XXX <- str(X)
fix(XXX)
fix(XXX)
fix(XXX)
XXX
str(X)
as.matrix(X)
as.matrix(as.data.frame(X))
as.data.frame(X)
c = as.data.frame(X)
c %*% c
c %*% t(c)
c = as.matrix(X)
c %*% t(c)
c = as.data.frame(as.matrix(X))
c
c %*% t(c)
c = [1,2,3]
c = [1 2 3]
c=[1 2 3]
q()
q()
train <- read.csv("~/data/Download/optdigits.tra", header=FALSE)
View(train)
train<-as.matrix(train)
View(train)
colors<-c('white','black')
cus_col<-colorRampPalette(colors=colors)
par(mfrow=c(4,3),pty='s',mar=c(1,1,1,1),xaxt='n',yaxt='n')
all_img<-array(dim=c(10,28*28))
for(di in 0:9)
{
print(di)
all_img[di+1,]<-apply(train[train[,1]==di,-1],2,sum)
all_img[di+1,]<-all_img[di+1,]/max(all_img[di+1,])*255
z<-array(all_img[di+1,],dim=c(28,28))
z<-z[,28:1] ##right side up
image(1:28,1:28,z,main=di,col=cus_col(256))
}
source('~/.active-rstudio-document')
par(mfrow=c(4,3),pty='s',mar=c(1,1,1,1),xaxt='n',yaxt='n')
all_img<-array(dim=c(10,28*28))
for(di in 0:9)
{
print(di)
all_img[di+1,]<-apply(train[train[,1]==di,-1],2,sum)
all_img[di+1,]<-all_img[di+1,]/max(all_img[di+1,])*255
z<-array(all_img[di+1,],dim=c(28,28))
image(1:28,1:28,z,main=di,col=cus_col(256))
}
for(di in 1:9)
for(di in 1:9)
{
print(di)
all_img[di+1,]<-apply(train[train[,1]==di,-1],2,sum)
all_img[di+1,]<-all_img[di+1,]/max(all_img[di+1,])*255
z<-array(all_img[di+1,],dim=c(28,28))
z<-z[,28:1] ##right side up
image(1:28,1:28,z,main=di,col=cus_col(256))
}
image(1:28,1:28,z,main=di,col=cus_col(256))
View(train)
View(all_img)
View(train)
View(all_img)
View(all_img)
a=c(1,2,3,4)
a[1:-1]
a[1:-1]
a[1:]
?len
?size
?count
?l
?length
length(a)
a[1: length(a)-1]
a[1: length(a)-1]
type(a[1: length(a)-1])
class(a[1: length(a)-1])
a[1: length(a)-1]
xs<-as.matrix(train[1:length(train)-1])
View(xs)
train <- read.csv("~/data/Download/optdigits.tra", header=FALSE)
xs<-as.matrix(train[1:length(train)-1])
View(xs)
y<-as.vector(train[length(train)-1, length(train)])
View(xs)
y<-as.vector(train[length(train)-1, length(train)])
train <- read.csv("~/data/Download/optdigits.tra", header=FALSE)
y<-as.vector(train[length(train)-1, length(train)])
y
y<-as.martix(train[length(train)-1, length(train)])
y<-as.matrix(train[length(train)-1, length(train)])
y
train <- read.csv("~/data/Download/optdigits.tra", header=FALSE)
xs<-as.matrix(train[1:length(train)-1])
y<-as.matrix(train[length(train)-1, length(train)])
y
y<-as.matrix(train[length(train)-1: length(train)])
y<-as.vector(train[length(train)-1: length(train)])
View(y)
xs<-as.matrix(train[1:length(train)-1])
y<-as.vector(train[length(train)-1:length(train)])
t=length(train)
xs<-as.matrix(train[1:t-1])
y<-as.vector(train[t-1:t])
y
View(y)
train[t-1:t]
train[1:2]
t
train[64:65]
train[65:65]
y<-as.vector(train[t:t])
y<-as.vector(train[t:t])
y
View(xs)
##Color ramp def.
colors<-c('white','black')
cus_col<-colorRampPalette(colors=colors)
## Plot the average image of each digit
par(mfrow=c(4,3),pty='s',mar=c(1,1,1,1),xaxt='n',yaxt='n')
all_img<-array(dim=c(10,28*28))
for(di in 1:9)
{
print(di)
all_img[di+1,]<-apply(x[x[,1]==di,-1],2,sum)
all_img[di+1,]<-all_img[di+1,]/max(all_img[di+1,])*255
z<-array(all_img[di+1,],dim=c(28,28))
z<-z[,28:1] ##right side up
image(1:28,1:28,z,main=di,col=cus_col(256))
}
##Color ramp def.
colors<-c('white','black')
cus_col<-colorRampPalette(colors=colors)
## Plot the average image of each digit
par(mfrow=c(4,3),pty='s',mar=c(1,1,1,1),xaxt='n',yaxt='n')
all_img<-array(dim=c(10,28*28))
for(di in 1:9)
{
print(di)
all_img[di+1,]<-apply(xs[xs[,1]==di,-1],2,sum)
all_img[di+1,]<-all_img[di+1,]/max(all_img[di+1,])*255
z<-array(all_img[di+1,],dim=c(28,28))
z<-z[,28:1] ##right side up
image(1:28,1:28,z,main=di,col=cus_col(256))
}
## Plot the average image of each digit
par(mfrow=c(4,3),pty='s',mar=c(1,1,1,1),xaxt='n',yaxt='n')
all_img<-array(dim=c(10,32*32))
for(di in 1:9)
{
print(di)
all_img[di+1,]<-apply(xs[xs[,1]==di,-1],2,sum)
all_img[di+1,]<-all_img[di+1,]/max(all_img[di+1,])*255
z<-array(all_img[di+1,],dim=c(32,32))
z<-z[,32:1] ##right side up
image(1:32,1:32,z,main=di,col=cus_col(256))
}
all_img<-array(dim=c(10,32*32))
View(all_img)
View(all_img)
all_img[di+1,]<-apply(xs[xs[,1]==di,-1],2,sum)
View(xs)
?image
xs[1]
xs[1:1]
xs
xs(1)
xs[1:]
xs[1:2]
xs[2:2]
xs[2:2][:]
xs[:]
xs[]
xs[][]
xs[1][]
xs[1:1][]
xs[][1]
image(1:8,1:8,xs)
demo(plotmath)
demo(plot)
?demo
demo(package = .packages(all.available = TRUE))
?pretty
pretty(c(-3,3))
pretty(c(-3,3), 30)
?dnorm
x<-pretty(c(-3,3), 30)
dnorm(x)
dnorm(1)
dnorm(1)
dnorm(2)
dnorm(10)
dnorm(1)
dnorm(2)
curve(dnorm(1))
curve(dnorm(1),-5,5)
curve(dnorm(x),-5,5)
curve(dnorm(y),-5,5)
curve(dnorm(x))
curve(dnorm(x),-5,5)
curve(dnorm(x,sd=2),-5,5)
curve(dnorm(x,sd=3),-5,5)
curve(dnorm(x,sd=5),-5,5)
curve(dnorm(x,sd=-1),-5,5)
curve(dnorm(x,sd=0.1),-5,5)
?apply
scale(c(1,2,3,4,50))
scale(c(1,2,3,4,50))
?scale
library(slidify)
library("slidifyLibraries", lib.loc="/home/sam/R/x86_64-unknown-linux-gnu-library/3.1")
---
---
title       : Introduction to Clojure
subtitle    :
author      : SzuHsien Lee
job         :
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      #
widgets     : []            # {mathjax, quiz, bootstrap}
mode        : selfcontained # {standalone, draft}
---
## Introduction to Clojure
---
### History of programming languages
* 1957 - FORTRAN
* 1958 - LISP
* 1959 - COBOL
* 1964 - BASIC
* 1970 - Forth
* 1972 - C
* 1972 - Smalltalk
* 1983 - C++
* 1986 - Erlang
* 1987 - Perl
* 1990 - Haskell
* 1991 - Python, Visual Basic
* 1993 - Ruby
* 1995 - Java,  JavaScript, PHP
* 2001 - C# / Visual Basic .NET
* 2003 - Scala
* <font color=red>2007 - Clojure</font>
* 2009 - Go
---
### Clojure Status
* started in 2007
* Original author: Rich Hickey
* Latest Stable Release: 1.6.0 (April, 2014)
---
### What is Clojure?
* Lisp dialect (Code as data)
* Dynamic
* Functional (immutability)
* General-purpose
* Compiled
* Hosted on JVM, also CLR and JavaScript
* Open Source under Eclipse Public License
---
###  Why use Clojure
* More fun & less code
* Focus on problem
* Supporting concurrency by default
* Interactive programming
* Robust, practical & high-performance
* Java ecosystem
---
## What is Functional programming
---
**Functional programming** is a style of building the structure and elements of computer programs, that treats computation as the evaluation of mathematical functions and avoids state and mutable data.
---
### Functional Progamming
* First-class functions
* Immutability
* Pure functions (no side effect)
* Recursion
* Expression
* Compose functions
* Lazy evaluation
---
## Let's Get Started
---
### Hello World
``` clojure
(defn hello
"Say hello world!"
[] (println "Hello World!"))
(hello)
;Hello World!
;=> nil
```
---
### Hello World 2
``` clojure
(defn hello
"Say hello to someone!"
([] (println "Hello World"))
([someone] (println "Hello" someone)))
(hello)
;Hello World!
;=> nil
(hello "Sam")
;Hello Sam
;=> nil
```
---
## Clojure Syntax
---
### Actomic Data Types
* Boolean: true false
* Number: 1234567890876544321, 1.23, 25/7
* String: "hello"
* Character: \c \b \a \space
* Null: nil
* Symbol: fred ethel
* Keyword: :fred :ethel
* Regex pattern: #"...pattern..."
---
"It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures."
\- Alan J. Perlis (Epigrams in Programming)
---
### Clojure Data Structures
* List: <font color=green>(1 2 3 4 5), ("abc" "bac" "aaa"), (list 1 2 3)</font>
* Vector: [1 2 3 4 5], [Mon Tue Wen Thu]
* Map: {:a 1, :b 2, :c 3}, {1 "one" 2 "two"}
* Set: #{"foo" "bar" "baz"}
library("slidify", lib.loc="/home/sam/R/x86_64-unknown-linux-gnu-library/3.1")
library("slidifyLibraries", lib.loc="/home/sam/R/x86_64-unknown-linux-gnu-library/3.1")
library("slidifyLibraries", lib.loc="/home/sam/R/x86_64-unknown-linux-gnu-library/3.1")
library("slidify", lib.loc="/home/sam/R/x86_64-unknown-linux-gnu-library/3.1")
publish(user = "misgod", repo = "slide-introduction2clojure")
mode        : selfcontained # {standalone, draft}
publish(user = "misgod", repo = "slide-introduction2clojure")
slidify("index.Rmd")
getwd()
setwd("~/git/mydesk")
setwd("/home/sam/git/mydesk")
setwd("/home/sam/git/mydeck")
slidify("index.Rmd")
publish(user = "misgod", repo = "slide-introduction2clojure")
